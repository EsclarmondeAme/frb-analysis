import numpy as np
import pandas as pd
import json
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
from astropy.coordinates import SkyCoord
import astropy.units as u

# -----------------------------------------------------------------------------------
# MODEL: FRBs lie preferentially near the surface of a cone around some axis vector n
# Score = sum( cos(theta_i - alpha)^2 )  where theta_i = arccos( n · r_i )
# -----------------------------------------------------------------------------------

def load_frbs():
    df = pd.read_csv("frbs.csv")
    mask = np.isfinite(df["ra"]) & np.isfinite(df["dec"])
    df = df[mask]
    return df

def frb_vectors(df):
    """
    convert RA/Dec to 3d unit vectors
    """
    coords = SkyCoord(ra=df["ra"].values*u.deg,
                      dec=df["dec"].values*u.deg,
                      frame="icrs")
    x = coords.cartesian.x.value
    y = coords.cartesian.y.value
    z = coords.cartesian.z.value
    v = np.vstack([x, y, z]).T
    return v

# -----------------------------------------------------------------------------------
# likelihood function
# -----------------------------------------------------------------------------------

def cone_score(axis, alpha, frb_vecs):
    """
    axis : 3-vector unit
    alpha : rad, cone half-angle
    frb_vecs : Nx3
    """
    axis = axis / np.linalg.norm(axis)
    dots = np.clip(frb_vecs @ axis, -1, 1)
    thetas = np.arccos(dots)
    return np.sum((np.cos(thetas - alpha))**2)

# -----------------------------------------------------------------------------------
# fit routine
# -----------------------------------------------------------------------------------

def random_unit_vector():
    v = np.random.normal(size=3)
    return v / np.linalg.norm(v)

def fit_cone(frb_vecs, n_iter=50000):
    """
    random search (adequate for 3D direction + 1 param)
    """
    best_score = -np.inf
    best_axis = None
    best_alpha = None
    
    for _ in range(n_iter):
        axis = random_unit_vector()
        alpha = np.random.uniform(0, np.pi/2)
        s = cone_score(axis, alpha, frb_vecs)
        if s > best_score:
            best_score = s
            best_axis = axis
            best_alpha = alpha

    return best_axis, best_alpha, best_score

# -----------------------------------------------------------------------------------
# plotting
# -----------------------------------------------------------------------------------

def plot_cone(axis, alpha, frb_vecs):
    fig = plt.figure(figsize=(10,10))
    ax = fig.add_subplot(111, projection='3d')

    # FRB points
    ax.scatter(frb_vecs[:,0], frb_vecs[:,1], frb_vecs[:,2],
               s=10, alpha=0.4, color="steelblue")

    # axis vector
    ax.quiver(0,0,0,
              axis[0], axis[1], axis[2],
              length=1.2, color="red", linewidth=3)

    # cone surface
    # generate circle orthogonal to axis
    N = 200
    phi = np.linspace(0, 2*np.pi, N)
    # orthonormal basis around axis
    # pick arbitrary vector not parallel to axis
    tmp = np.array([1,0,0])
    if abs(np.dot(tmp, axis)) > 0.9:
        tmp = np.array([0,1,0])
    uvec = np.cross(axis, tmp)
    uvec /= np.linalg.norm(uvec)
    vvec = np.cross(axis, uvec)
    vvec /= np.linalg.norm(vvec)
    # radius of cone at unit height
    r = np.tan(alpha)
    xs = axis[0] + r*(uvec[0]*np.cos(phi) + vvec[0]*np.sin(phi))
    ys = axis[1] + r*(uvec[1]*np.cos(phi) + vvec[1]*np.sin(phi))
    zs = axis[2] + r*(uvec[2]*np.cos(phi) + vvec[2]*np.sin(phi))
    ax.plot(xs, ys, zs, color="orange", linewidth=2)

    ax.set_box_aspect([1,1,1])
    ax.set_xlim(-1,1)
    ax.set_ylim(-1,1)
    ax.set_zlim(-1,1)
    ax.set_title("3D Cone-Axis Reconstruction")
    plt.savefig("frb_cone_axis_3d.png", dpi=150, bbox_inches="tight")
    print("[saved] frb_cone_axis_3d.png")

# -----------------------------------------------------------------------------------
# monte-carlo uncertainties
# -----------------------------------------------------------------------------------

def monte_carlo_uncertainties(frb_vecs, axis, alpha, n=2000):
    """
    bootstrap FRBs to estimate axis & angle uncertainties
    """
    axes = []
    alphas = []

    N = len(frb_vecs)

    for _ in range(n):
        idx = np.random.randint(0, N, N)
        sub = frb_vecs[idx]
        a, b, _ = fit_cone(sub, n_iter=5000)
        axes.append(a)
        alphas.append(b)

    axes = np.array(axes)
    alphas = np.array(alphas)

    # mean axis (normalized)
    mean_axis = np.mean(axes, axis=0)
    mean_axis /= np.linalg.norm(mean_axis)

    # dispersion of directions
    dot = np.clip(axes @ mean_axis, -1, 1)
    ang_disp = np.degrees(np.arccos(dot))
    sigma_axis = np.std(ang_disp)

    sigma_alpha = np.std(alphas)

    return sigma_axis, sigma_alpha

# -----------------------------------------------------------------------------------
# main
# -----------------------------------------------------------------------------------

def main():
    print("="*60)
    print("3D FRB CONE-AXIS RECONSTRUCTION")
    print("="*60)

    frbs = load_frbs()
    print(f"loaded FRBs:", len(frbs))

    frb_vecs = frb_vectors(frbs)

    print("[fit] running random search...")
    axis, alpha, score = fit_cone(frb_vecs, n_iter=60000)

    # axis → RA/dec
    coord = SkyCoord(x=axis[0], y=axis[1], z=axis[2],
                     representation_type="cartesian").icrs

    ra = coord.ra.deg
    dec = coord.dec.deg

    print("")
    print("RESULTS")
    print("----------------------------------")
    print(f"axis RA  = {ra:.2f} deg")
    print(f"axis Dec = {dec:.2f} deg")
    print(f"cone half-angle α = {np.degrees(alpha):.2f} deg")

    print("[uncertainties] bootstrapping...")
    sig_axis, sig_alpha = monte_carlo_uncertainties(frb_vecs, axis, alpha)

    print(f"axis 1σ angular uncertainty = {sig_axis:.2f} deg")
    print(f"alpha 1σ uncertainty = {np.degrees(sig_alpha):.2f} deg")

    # save results JSON
    out = {
        "axis_vector": axis.tolist(),
        "ra_deg": float(ra),
        "dec_deg": float(dec),
        "alpha_deg": float(np.degrees(alpha)),
        "axis_uncertainty_deg": float(sig_axis),
        "alpha_uncertainty_deg": float(np.degrees(sig_alpha)),
    }
    with open("frb_cone_axis_3d.json", "w") as f:
        json.dump(out, f, indent=4)
    print("[saved] frb_cone_axis_3d.json")

    # plot
    plot_cone(axis, alpha, frb_vecs)

if __name__ == "__main__":
    main()
